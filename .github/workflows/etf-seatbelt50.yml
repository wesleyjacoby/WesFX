name: Seatbelt50 Monthly Notifier

on:
  schedule:
    # 20:30 SAST == 18:30 UTC
    - cron: "30 18 28 * *"
  workflow_dispatch: {}

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas numpy yfinance

      - name: Send Telegram instruction
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          START_YEAR: "2006"
          MONTHLY_CONTRIB: "1000"
        run: |
          python - <<'PY'
          import os, json, urllib.request, urllib.parse, datetime as dt
          import numpy as np, pandas as pd, yfinance as yf

          SEATBELT_M = 10
          E1_CANDS = ["STXWDM.JO","SYGWD.JO","STX500.JO"]
          E2_CANDS = ["STX40.JO"]
          B_CANDS  = ["STXGOV.JO"]

          def first_avail(ts):
              for t in ts:
                  try:
                      if not yf.Ticker(t).history(period="5d").empty:
                          return t
                  except Exception:
                      pass
              raise RuntimeError(f"No live data for any of: {ts}")

          def ensure_utc_index(df):
              idx = df.index
              if getattr(idx, "tz", None) is None:
                  df.index = pd.to_datetime(idx, utc=True)
              else:
                  df.index = idx.tz_convert("UTC")
              return df

          def dl_monthly_close(ticker, start):
              df = yf.download(ticker, start=start, interval="1d", auto_adjust=True, progress=False)
              if df is None or df.empty:
                  return pd.Series(dtype=float, name=ticker)
              df = ensure_utc_index(df)
              m = df["Close"].resample("ME").last().dropna().astype(float)
              m.name = ticker
              # ensure unique month-end index
              return m[~m.index.duplicated(keep="last")]

          def scalar_or_nan(s, t):
              try:
                  v = s.loc[t]
                  if isinstance(v, (pd.Series, pd.DataFrame)):
                      v = v.iloc[-1]
                  return float(v)
              except Exception:
                  return np.nan

          def seatbelt_weights(e1,e2,b):
              common = e1.index.intersection(e2.index).intersection(b.index).sort_values()
              e1, e2, b = e1.loc[common], e2.loc[common], b.loc[common]
              ma1, ma2 = e1.rolling(SEATBELT_M).mean(), e2.rolling(SEATBELT_M).mean()
              t = common[-1]
              p1 = scalar_or_nan(e1,t); p2 = scalar_or_nan(e2,t)
              m1 = scalar_or_nan(ma1,t); m2 = scalar_or_nan(ma2,t)
              # Risk-on if either equity above its 10M MA; early months (NaN MAs) default risk-on
              risk_on = (not np.isnan(m1) and not np.isnan(p1) and p1 >= m1) or \
                        (not np.isnan(m2) and not np.isnan(p2) and p2 >= m2) or \
                        (np.isnan(m1) and np.isnan(m2))
              if risk_on:
                  return t, 0.5, 0.5, 0.0, "RISK-ON"
              else:
                  return t, 0.0, 0.0, 1.0, "DEFENSIVE"

          bot = os.environ["TELEGRAM_BOT_TOKEN"]
          chat= os.environ["TELEGRAM_CHAT_ID"]
          start_year = os.getenv("START_YEAR","2006")
          contrib = float(os.getenv("MONTHLY_CONTRIB","1000"))

          syms = {
              "E1": first_avail(E1_CANDS),
              "E2": first_avail(E2_CANDS),
              "B":  first_avail(B_CANDS),
          }

          e1 = dl_monthly_close(syms["E1"], f"{start_year}-01-01")
          e2 = dl_monthly_close(syms["E2"], f"{start_year}-01-01")
          b  = dl_monthly_close(syms["B"],  f"{start_year}-01-01")

          t, w1, w2, wb, regime = seatbelt_weights(e1,e2,b)
          r1, r2, rb = contrib*w1, contrib*w2, contrib*wb

          now_sast = dt.datetime.utcnow() + dt.timedelta(hours=2)
          hdr_date = now_sast.strftime("%Y-%m-%d %H:%M") + " SAST"

          if wb == 0.0:
              text = (
                  f"*Seatbelt 50/50 — Monthly Instruction*\\n"
                  f"{hdr_date}\\n\\n"
                  f"As of {pd.to_datetime(t).date()} — *{regime}*\\n\\n"
                  f"Contribute R{contrib:,.0f} split:\\n"
                  f"• {syms['E1']}: *R{r1:,.0f}* (50%)\\n"
                  f"• {syms['E2']}: *R{r2:,.0f}* (50%)\\n"
                  f"• {syms['B']}:  R0 (0%)\\n"
              )
          else:
              text = (
                  f"*Seatbelt 50/50 — Monthly Instruction*\\n"
                  f"{hdr_date}\\n\\n"
                  f"As of {pd.to_datetime(t).date()} — *{regime}*\\n\\n"
                  f"Contribute R{contrib:,.0f} to bonds:\\n"
                  f"• {syms['B']}: *R{rb:,.0f}* (100%)\\n"
                  f"• {syms['E1']}: R0 (0%)\\n"
                  f"• {syms['E2']}: R0 (0%)\\n"
              )

          base = f"https://api.telegram.org/bot{bot}/sendMessage"
          data = urllib.parse.urlencode({
              "chat_id": chat,
              "text": text,
              "parse_mode": "Markdown",
              "disable_web_page_preview": True
          }).encode("utf-8")
          with urllib.request.urlopen(urllib.request.Request(base, data=data), timeout=20) as resp:
              print("Telegram sent:", json.loads(resp.read().decode()).get("ok", False))
          PY
